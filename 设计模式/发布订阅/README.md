### 利用“发布-订阅”模式驱动数据流

- “发布-订阅”模式可谓是解决通信类问题的“万金油”，在前端世界的应用非常广泛，比如：前两年爆火的 socket.io 模块，它就是一个典型的跨端发布-订阅模式的实现；在 Node.js 中，许多原生模块也是以 EventEmitter 为基类实现的；不过大家最为熟知的，应该还是 Vue.js 中作为常规操作被推而广之的“全局事件总线” EventBus。

- 这些应用之间虽然名字各不相同，但内核是一致的，

### 理解事件的发布-订阅机制
- 发布-订阅机制早期最广泛的应用，应该是在浏览器的 DOM 事件中。
```js
  target.addEventListener(type, listener, useCapture);
```
- 通过调用 addEventListener 方法，我们可以创建一个事件监听器，这个动作就是“订阅”。比如我可以监听 click（点击）事件：
```js
  el.addEventListener("click", func, false);
```
- 这样一来，当 click 事件被触发时，事件会被“发布”出去，进而触发监听这个事件的 func 函数。这就是一个最简单的发布-订阅案例。

- 使用发布-订阅模式的优点在于，**监听事件的位置和触发事件的位置是不受限的**，就算相隔十万八千里，只要它们在同一个上下文里，就能够彼此感知。这个特性，太适合用来应对“任意组件通信”这种场景了。

### 发布-订阅模型 API 设计思路
- 不难看出发布-订阅模式中有两个关键的动作：事件的监听（订阅）和事件的触发（发布），这两个动作自然而然地对应着两个基本的 API 方法。

- on()：负责注册事件的监听器，指定事件触发时的回调函数。
- emit()：负责触发事件，可以通过传参使其在触发的时候携带数据。