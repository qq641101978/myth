### webpack
- **从一个打包工具变成了一个前端构建系统**
- webpack 的工作原理，webpack 的执行过程大体上可以分为 3 个步骤，包括：检验配置项、创建编译器、执行编译。

- 在 检验 配置项时使用了 JSONSchema 来校验配置参数。

- 在创建编译器时，用到了 tapable 模块提供的钩子机制，通过触发适当的钩子事件来让对应的插件进行初始化。

- 在执行编译阶段，以 compiler.hooks.make 钩子事件为起始点，触发入口文件的解析工作，并调用加载器对资源进行处理，然后构建成抽象语法树，将最终的抽象语法树转换成目标文件并输出到配置项指定的目录。

## webpack v4.42.1 版本展开
- 解决的问题：开发阶段的模块化
- 怎么解决
- 从打包工具 变成 构建系统

- 关键词：ES Modules

### Loader
- **loader，它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。**
- 各种资源模块的加载，实现整体资源的模块化
- use数组的解析顺序从后到前

### Plugin 
- **plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务**
- 增强 Webpack 在项目自动化构建方面的能力

- 我在这里先介绍几个插件最常见的应用场景：

  1. 实现自动在打包之前清除 dist 目录（上次的打包结果）；

  2. 自动生成应用所需要的 HTML 文件；

  3. 根据不同环境为代码注入类似 API 地址这种可能变化的部分；

  4. 拷贝不需要参与打包的资源文件到输出目录；

  5. 压缩 Webpack 打包完成后输出的文件；

  6. 自动发布打包结果到服务器实现自动部署。

- 总之，有了 Plugin 的 Webpack 几乎“无所不能”。借助插件，我们就可以轻松实现前端工程化中绝大多数经常用到的功能，这也正是很多初学者会认为 “Webpack 就是前端工程化，或者前端工程化就是 Webpack” 的原因。
- plugin 实现：Webpack 要求我们的插件必须是一个函数或者是一个包含 apply 方法的对象

### webpack 核心工作环节
- webpack CLI 启动打包流程
- 载入 webpack 核心模块，创建了 Compiler 对象
- 使用 Compiler 对象开发编译整个项目
- 从入口文件开始，解析模块依赖，形成依赖关系树
- 递归依赖关系树，将每个模块交给对应的 Loader 处理
- 合并 Loader 处理完的结果，将打包结果输出到 dist 目录


### 打包结果运行原理
- 为了更好的理解打包后的代码，我们先将 Webpack 工作模式设置为 none，这样 Webpack 就会按照最原始的状态进行打包，所得到的结果更容易理解和阅读

- 打包后的 main.js 文件就是一个立即执行函数: 这个函数是 Webpack 工作入口（webpackBootstrap），它接收一个 modules 参数，调用时传入了一个数组。
- 函数意义：

### Webpack CLI 作用：
- 作用就是将 CLI 参数（命令行传入的参数）和 Webpack 配置文件中的配置整合得到一个完整对象。