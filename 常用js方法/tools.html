<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
  .demo{
      position: absolute;
      right: 0px;
  }
  .demo1{
      position: absolute;
      top: 100px;
      right: 0px;
      font-size: 12px;
  }
  </style>
</head>
<body>
  <script>
    // 这用来修改现有对象部分的属性就很方便了。
    // let newVersion = {
    //   ...previousVersion,
    //   name: 'New Name' // 新属性 替换掉 previousVersion 的name
    // };

    // 数字数组去重 利用迭代的性质
    function unique(array) {
      return Array.from(new Set(array));
    }
    unique([1, 1, 2, 3, 3]); // => [1, 2, 3]

    // 对象数组去重
    function sortFn(arr,b) {
        let p = []
        b.forEach(el => {
            p.push(arr[el])
        })
        arr.unshift(...p)
        const obj = {};
        arr = arr.reduce((item, next)=> {
            obj[next.id] ? '' : obj[next.id] = true && item.push(next);
            return item;
        }, []);
        console.log(obj)

    }
    // sortFn(arr, b)

    //去除空格  type 1-所有空格  2-前后空格  3-前空格 4-后空格
    //ecDo.trim('  1235asd',1)
    //result：1235asd
    //这个方法有原生的方案代替，但是考虑到有时候开发PC站需要兼容IE8，所以就还是继续保留
    function trim(str, type = 1) {
        switch (type) {
            case 1:
                return str.replace(/\s+/g, "");
            case 2:
                return str.replace(/(^\s*)|(\s*$)/g, "");
            case 3:
                return str.replace(/(^\s*)/g, "");
            case 4:
                return str.replace(/(\s*$)/g, "");
            default:
                return str;
        }
    }
    // 对数字的某个位子添加数据
    const ThousandNum = num => num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    const money = ThousandNum(20190214);
    // money => "20,190,214"

    // 生成随机ID
    const RandomId = len => Math.random().toString(36).substr(3, len);
    const id = RandomId(10);
    // id => "jg7zpgiqva"

    // 生成随机HEX色值
    const RandomColor = () => "#" + Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, "0");
    const color = RandomColor();
    // color => "#f03665"

    // 生成星级评分
    const StartScore = rate => "★★★★★☆☆☆☆☆".slice(5 - rate, 10 - rate);
    const start = StartScore(3);
    // start => "★★★"
    // 补零
    const FillZero = (num, len) => num.toString().padStart(len, "0");
    const num = FillZero(169, 5);
    // num => "00169"

    // 时间戳 关键在于 +
    const timestamp = +new Date("2019-02-14");
    // timestamp => 1550102400000

    // 精确小数
    const RoundNum = (num, decimal) => Math.round(num * 10 ** decimal) / 10 ** decimal;
    const num1 = RoundNum(1.6939, 3);
    
    // 可判断类型：undefined、null、string、number、boolean、array、object、symbol、date、regexp、function、asyncfunction、arguments、set、map、weakset、weakmap
    // 判断数据类型
    function DataType(tgt, type) {
        const dataType = Object.prototype.toString.call(tgt).replace(/\[object /g, "").replace(/\]/g, "").toLowerCase();
        return type ? dataType === type : dataType;
    }
    DataType("young"); // "string"
    DataType(20190214); // "number"
    DataType(true); // "boolean"
    DataType([], "array"); // true
    DataType({}, "array"); // false

    // 判断数组是否为空
    // const arr = [];
    // const flag = Array.isArray(arr) && !arr.length;
    // flag => true
    // 判断对象是否为空
    // const obj = {};
    // const flag = DataType(obj, "object") && !Object.keys(obj).length;
    // flag => true
    
    // 满足条件时执行（思路：在计算监听属性中写判断执行条件）
    const flagA = true; // 条件A
    const flagB = false; // 条件B
    function Func(){}
    (flagA || flagB) && Func(); // 满足A或B时执行
    (flagA || !flagB) && Func(); // 满足A或不满足B时执行
    flagA && flagB && Func(); // 同时满足A和B时执行
    flagA && !flagB && Func(); // 满足A且不满足B时执行

    // 统计数组成员个数
    const arr = [0, 1, 1, 2, 2, 2];
    // 方法1
    const count = arr.reduce((t, c) => {
        t[c] = t[c] ? ++ t[c] : 1;
        return t;
    }, {});
    // count => { 0: 1, 1: 2, 2: 3 }
    // 方法2
    const count1 = new Set(arr)
    // console.log(count1.size)

    
    const dev = 'name'
    const link = {
        name: 'byf',
        age: 13
    }[dev]
    // console.log(link)

    // 一次性函数
    function Func() {
        // console.log("x");
        Func = function() {
            // console.log("y");
        }
    }
    // 调试页面元素边界时使用
    // [].forEach.call($("*"), dom => {
    //     dom.style.outline = "1px solid #" + (~~(Math.random() * (1 << 24))).toString(16);
    // });
    //判断结尾是否是这个元素
    let str = 'asdfghjkl'
    // console.log(str.indexOf('kl'))
    // console.log(str.length - 'kl'.length)

    // 节流（保证了函数会在第一时间执行，后面才需要时间间隔）
    function throttle(func, gapTime){
        if(typeof func !== 'function') {
            // throw new TypeError('need a function');
            throw Error('need a function')
        }
        // 1000
        gapTime = +gapTime || 0;
        let lastTime = 0;
        return function() {
            let time = + new Date();
            if(time - lastTime > gapTime || !lastTime) {
                func();
                // 返回上一次时间，形成时间间隔
                lastTime = time;
            }
        }
    }
    // 执行节流 10ms 执行一次 实际上是 1s打印一次
    // setInterval(throttle(() => {
    //     console.log('xxx')
    // }, 1000),10)
    // 我的debounce 实现
    function my_debounce(func, wait) {
        if(typeof func !== 'function') {
            throw new TypeError('need a function');
        }
        wait = +wait || 0;
        let timeId = null;
        return function() {
            // console.log('滚动了滚动了');  // 测试时可放开
            const self = this;
            const args = arguments;
            if(timeId) {
                clearTimeout(timeId);   // 清除定时器，重新设定一个新的定时器
            }
            timeId =  setTimeout(() => {
                func.apply(self, args); // arguments 是传给函数的参数，这里是 event  对象
            }, wait);
        }
    }
    function onScroll_1() {
        console.log('执行滚动处理函数啦');  
    }
    window.addEventListener('scroll', my_debounce(onScroll_1, 1000));
    // 从上面的分析来看，这个单纯的 防抖函数还是有个硬伤的，是什么呢？
    // 那就是每次触发定时器就重新来，每次都重新来，如果某段时间用户一直一直触发，
    // 防抖函数一直重新设置定时器，就是不执行，频繁的延迟会导致用户迟迟得不到响应，
    // 用户同样会产生“这个页面卡死了”的观感

    //防抖，你已经是一个成熟的函数了。不要动不动就假死好吗
    
    // 解构取值:事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。
    let [foo, ...bar] = [1,2,3,4]
    console.log(foo, bar)

  </script>
</body>
</html>