主旨：异步与性能
# 开发者编写代码的时候是在计划一系列动作的发生。
### 类型
typeof 的安全防范机制：阻止报错
很多开发人员认为全局命名空间中不应该有变量存在，所有东西都应该被封装到模块和私有 / 独立的命名空间中。理论上这没错，却不切实际。然而这仍不失为一个值得为之努力奋斗的目标。好在 ES6 中加入了对模块的支持，这使我们又向目标迈近了一步。
小结：
- JavaScript 有 七 种 内 置 类 型:null、undefined、boolean、number、string、object 和 symbol，可以使用 typeof 运算符来查看。
- 变量没有类型，但它们持有的值有类型。类型定义了值的行为特征。
- 很多开发人员将 undefined 和 undeclared 混为一谈，但在 JavaScript 中它们是两码事。undefined 是值的一种。undeclared 则表示变量还没有被声明过。
- 遗憾的是，JavaScript 却将它们混为一谈，在我们试图访问 "undeclared" 变量时这样报错:ReferenceError: a is not defined， 并 且 typeof 对 undefined 和 undeclared 变 量 都 返 回 "undefined"。
- 然而，通过 typeof 的安全防范机制(阻止报错)来检查 undeclared 变量，有时是个不错的办法。
### 值
#### 整数检测(es6 api): 
- 1:Number.isInteger(..) // true or false
- 2: (..) % 1 取于是否为0
- 安全的整数(不超过精度范围)： Number.isSafeInteger(..)
- NaN 判断：Number.isNaN(xx)  (window.isNaN() 区分不了字符串)
- 你可以从有 穷走向无穷，但无法从无穷回到有穷。
#### -0 问题 
- 1、从数字转为字符结果为 0
- 2、从字符转为数字结果为 -0
- 3、-0 === 0  为true  可以用Object.is(..) 来判断两个值是否绝对相等

#### 为啥需要 -0
抛开学术上的繁枝褥节不论，我们为什么需要负零呢?
有些应用程序中的数据需要以级数形式来表示(比如动画帧的移动速度)，数字的符号位 (sign)用来代表其他信息(比如移动的方向)。此时如果一个值为 0 的变量失去了它的符号位，它的方向信息就会丢失。所以保留 0 值的符号位可以防止这类情况发生。

#### 小结：
- JavaScript 中的数组是通过数字索引的一组任意类型的值。字符串和数组类似，但是它们的行为特征不同，在将字符作为数组来处理时需要特别小心。JavaScript 中的数字包括“整 数”和“浮点型”。
- 基本类型中定义了几个特殊的值。
- null 类型只有一个值 null，undefined 类型也只有一个值 undefined。所有变量在赋值之前默认值都是 undefined。void 运算符返回 undefined。
数字类型有几个特殊值，包括 NaN(意指“not a number”，更确切地说是“invalid number”)、+Infinity、-Infinity 和 -0。
- 简单标量基本类型值(字符串和数字等)通过值复制来赋值 / 传递，而复合值(对象等) 通过引用复制来赋值 / 传递。JavaScript 中的引用和其他语言中的引用 / 指针不同，它们不能指向别的变量 / 引用，只能指向值。

### 原生函数
>常用的原生函数有:
- String()
- Number()
- Boolean()
- Array()
- Object()
- Function()
- RegExp()
- Date()
- Error()
- Symbol()——ES6 中新加入的!

#### 小结：
JavaScript 为基本数据类型值提供了封装对象，称为原生函数(如 String、Number、Boolean 等)。它们为基本数据类型值提供了该子类型所特有的方法和属性(如:String#trim() 和 Array#concat(..))。
对于简单标量基本类型值，比如 "abc"，如果要访问它的 length 属性或 String.prototype 方法，JavaScript 引擎会自动对该值进行封装(即用相应类型的封装对象来包装它)来实现对这些属性和方法的访问。

### 第四章 强制类型转换
> 将值从一种类型转换为另一种类型通常称为类型转换(type casting)，这是显式的情况;隐式的情况称为强制类型转换(coercion)。
'~'字位操作符 非
~x 大致等同于 -(x+1)
判断一个字符的子串是否存在：原本不存在返回 -1,经过 ～ 运算，返回 0 
```js
if(!~'foo'.indexOf('f')) // true
```
解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字。但解析和转换两者之间还是有明显的差别。
```js
var a = "42"; 
var b = "42px";
Number( a );    // 42
parseInt( a );  // 42
Number( b );    // NaN
parseInt( b );  // 42
```
解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回 NaN。

隐式强制类型转换的作用是减少冗余，让代码更简洁。
守护运算符 &&
```js
function foo() { 
  console.log( a );
}
var a = 42;
a && foo(); // 42
```
正确的解释是:“== 允许在相等比较中进行强制类型转换，而 === 不允许。

```js
  var a = { b: 42 };
  var b = { b: 43 };
  a < b;  // false
  a == b; // false
  a > b;  // false
  a <= b; // true
  a >= b; // true
```
因为根据规范a <= b被处理为b < a，然后将结果反转。因为b < a的结果是false，所
以 a <= b 的结果是 true。
相等比较有严格相等，关系比较却没有“严格关系比较”(strict relational comparison)。也 就是说如果要避免a < b中发生隐式强制类型转换，我们只能确保a和b为相同的类型， 除此之外别无他法。
#### 小结
本章介绍了 JavaScript 的数据类型之间的转换，即强制类型转换:包括显式和隐式。
显式强制类型转换明确告诉我们哪里发生了类型转换，有助于提高代码可读性和可维护性。
隐式强制类型转换则没有那么明显，是其他操作的副作用。感觉上好像是显式强制类型转换的反面，实际上隐式强制类型转换也有助于提高代码的可读性。
在处理强制类型转换的时候要十分小心，尤其是隐式强制类型转换。在编码的时候，要知其然，还要知其所以然，并努力让代码清晰易读。

### 第5章 语法
#### 小结
- 语句和表达式在英语中都能找到类比——语句就像英语中的句子，而表达式就像短语。表达式可以是简单独立的，否则可能会产生副作用。

- JavaScript语法规则之上是语义规则(也称作上下文)。例如，{ }在不同情况下的意思不尽相同，可以是语句块、对象常量、解构赋值(ES6)或者命名函数参数(ES6)。

- JavaScript 详细定义了运算符的优先级(运算符执行的先后顺序)和关联(多个运算符的组合方式)。只要熟练掌握了这些规则，就能对如何合理地运用它们作出自己的判断。

- ASI(自动分号插入)是 JavaScript 引擎的代码解析纠错机制，它会在需要的地方自动插入分号来纠正解析错误。问题在于这是否意味着大多数的分号都不是必要的(可以省略)，或者由于分号缺失导致的错误是否都可以交给 JavaScript 引擎来处理。

- JavaScript 中有很多错误类型，分为两大类:早期错误(编译时错误，无法被捕获)和运行时错误(可以通过 try..catch 来捕获)。所有语法错误都是早期错误，程序有语法错误则无法运行。
全局变量的危害

- 函数参数和命名参数之间的关系非常微妙。尤其是 arguments 数组，它的抽象泄漏给我们挖了不少坑。因此，尽量不要使用 arguments，如果非用不可，也切勿同时使用 arguments 和其对应的命名参数。
- finally 中代码的处理顺序需要特别注意。它们有时能派上很大用场，但也容易引起困惑， 特别是在和带标签的代码块混用时。总之，使用 finally 旨在让代码更加简洁易读，切忌弄巧成拙。

- switch相对于if..else if..来说更为简洁。需要注意的一点是，如果对其理解得不够透彻，稍不注意就很容易出错。

# 异步:现在与将来
>从一开始，JavaScript 就涉及异步编程。但是，多数 JavaScript 开发者从来没有认真思考过自己程序中的异步到底是如何出现的，以及其为什么会出现，也没有探索过处理异步的其他法。一直以来，低调的回调函数就算足够好的方法了。目前为止，还有很多人坚持认为回调函数完全够用。
> 但是，作为在浏览器、服务器以及其他能够想到的任何设备上运行的一流编程语言，JavaScript 面临的需求日益扩大。为了满足这些需求，JavaScript 的规模和复杂性也在持续增长，对异步的管理也越来越令人痛苦，这一切都迫切需要更强大、更合理的异步方法。

- 一定要清楚，setTimeout(..) 并没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的 tick 会摘下并执行这个回调。