# 绝大多数 Web 开发者可能都没有创建过一个 JavaScript 对象，他们只是把 JavaScript 当作按钮和 AJAX 请求之间的事件绑定粘合剂。
- 将变量引入程序会引起几个很有意思的问题，也正是我们将要讨论的:这些变量住在哪里?换句话说，它们储存在哪里?最重要的是，程序需要时如何找到它们?
- 这些问题说明需要一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。 这套规则被称为作用域。
- 词法单元 
var a = 2; 分为 var、a、=、2、；。(空格是否会被当作词法单元，取决于空格在 这门语言中是否具有意义。
)
- 代码生成：
抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中。
- 重复声明会忽略当前的：当前

### 第一章：作用域规则
- 我们将“作用域”定义为一套规则，这套规则用来管理引擎如何在当前作用 域以及嵌套的子作用域中根据标识符名称进行变量查找。

- LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最 好将其理解为“赋值操作的目标是谁(LHS)”以及“谁是赋值操作的源头(RHS)”。

- LHS查询： 赋值操作，查询赋值的变量  （写,当读取不到这个变量当时候，在不严格模式下会全局创建这个变量）
- RHS查询：查询操作。查询变量和当前的值（读）
小练习：
function foo(a) { 
  var b = a;
  return a + b; 
}
var c = foo( 2 );

引擎：需要 foo()的 RHS 引用
作用域： ok
引擎：需要 a 的 LHS 引用
作用域： ok
引擎：需要 a 的 LHS 引用
作用域： ok
引擎：需要 a 的 RHS 引用
作用域： ok
引擎：需要 a, b 的 RHS 引用
作用域： ok
引擎：需要 c 的 LHS 引用
作用域： ok
RHS: 4次
LHS: 3次

报错相关：
ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对 结果的操作是非法或不合理的。
### 第二章：词法作用域(吃透)
词法作用域:  什么东西（变量的读写规则）
作用域的遮蔽效应：查找从内往外
欺骗词法：通过一些方法，把字符串解析可执行代码，改变当前作用域（动态生成代码）eval，with等
小结：
词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段 基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它 们进行查找。
### 第三章：函数作用域和块作用域
函数声明的意义："隐藏"变量，规避冲突

- 为什么“隐藏”变量和函数是一个有用的技术?
- 有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。

- 函数表达式和函数声明：区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置(不仅仅是一行代码，而是整个声明中的位置)。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。
- 函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。
- 为变量显式声明块作用域，并对变量进行本地绑定是非常有用的工具，可以把它添加到你的代码工具箱中了。
- 小结: 
1、函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。
2、但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，
也可以属于某个代码块(通常指 { .. } 内部)。

3、有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。

### 4提升：现有蛋🥚（申明）后有鸡🐔（赋值）
- 函数声明和变量声明都会被提升。但是一个值得注意的细节(这个细节可以出现在有多个
“重复”声明的代码中)是函数会首先被提升，然后才是变量。

### 5作用域闭包
本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使用了回调函数，实际上就是在使用闭包!
- 自己总结：闭包的结果：作用域的拖拽
- IIFE：立即执行函数
### 模块
> 模块模式需要具备两个必要条件。
1. 必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块 实例)。
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。

-  需要明确的是，事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。但是 this 机制某种程度上很像动态作用域。
- 主要区别:词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。(this 也是!)词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。

- ES6 的一个初衷就是帮助人们减少重复的场景，事实上包括修复某些习惯用法的问题，this 就是其中一个。
- 箭头函数将程序员们经常犯的一个错误给标准化了，也就是混淆了 this 绑定规则和词法作用域规则。
- this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计
得更加简洁并且易于复用。
-  this 的错误理解：

- this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。(谁调用，就指向谁)

- 调用栈：
- 调用位置：

```js
function baz() {
  // 当前调用栈是:baz
  // 因此，当前调用位置是全局作用域
  console.log( "baz" );
  bar(); // <-- bar 的调用位置 
}
function bar() {
  // 当前调用栈是 baz -> bar
  // 因此，当前调用位置在 baz 中
  console.log( "bar" );
  foo(); // <-- foo 的调用位置 
}
function foo() {
  // 当前调用栈是 baz -> bar -> foo 
  // 因此，当前调用位置在 bar 中
  console.log( "foo" ); 
}
baz(); // <-- baz 的调用位置
```
小结：
> 如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。
1. 由new调用?绑定到新创建的对象。
2. 由call或者apply(或者bind)调用?绑定到指定的对象。
3. 由上下文对象调用?绑定到那个上下文对象。
4. 默认:在严格模式下绑定到undefined，否则绑定到全局对象。
- 一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。
- ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这其实和 ES6 之前代码中的 self = this 机制一样。

### 对象：
- 在 JavaScript中一共有六种主要类型：string, number, boolean, object, null, undefined,
- 简单基本类型(string、boolean、number、null 和 undefined)本身并不是对象。
- null 判为 object 的原因：原理是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。

- 内置对象: JavaScript 中还有一些对象子类型，通常被称为内置对象,有些内置对象的名字看起来和简单基础类型一样，不过实际上它们的关系更复杂.它们实际上只是一些内置函数,这些内置函数可以当作构造函数 (由 new 产生的函数调用)来使用
- 内置对象: String, Number, Object, Function, Array, Boolean, Date, Regexp, Error
- 字面量 ?

小结：
JavaScript 中的对象有字面形式(比如 var a = { .. })和构造形式(比如 var a = new Array(..))。字面形式更常用，不过有时候构造形式可以提供更多选项。
许多人都以为“JavaScript 中万物都是对象”，这是错误的。对象是 6 个(或者是 7 个，取 决于你的观点)基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同 的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。
对象就是键 / 值对的集合。可以通过 .propName 或者 ["propName"] 语法来获取属性值。访 问属性时，引擎实际上会调用内部的默认 [[Get]] 操作(在设置属性值时是 [[Put]])， [[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话还会查找 [[Prototype]] 链(参见第 5 章)。
属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用 Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象(及其 属性)的不可变性级别。
属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是 可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。
你可以使用 ES6 的 for..of 语法来遍历数据结构(数组、对象，等等)中的值，for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。
- 多重继承? js没有提供（可以模拟），怎么解决继承冲突问题。
- js可以混入：extend(..)，mixin(...)
- 函数无法真正的赋值，只能被不同地方引用

### 类
小结：
- 类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。JavaScript 也有类似的语法，但是和其他语言中的类完全不同。
- 类意味着复制。
- 传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。
- 多态(在继承链的不同层次名称相同但是功能不同的函数)看起来似乎是从子类引用父 类，但是本质上引用的其实是复制的结果。
- JavaScript 并不会(像类那样)自动创建对象的副本。
- 混入模式(无论显式还是隐式)可以用来模拟类的复制行为，但是通常会产生丑陋并且脆 弱的语法，比如显式伪多态(OtherObj.methodName.call(this, ...))，这会让代码更加难懂并且难以维护。
- 此外，显式混入实际上无法完全模拟类的复制行为，因为对象(和函数!别忘了函数也 是对象)只能复制引用，无法复制被引用的对象或者函数本身。忽视这一点会导致许多问题。
- 总地来说，在 JavaScript 中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋下更多的隐患。

### 原型
> 继承意味着复制操作，JavaScript(默认)并不会复制对象属性。相反，JavaScript 会在两个对象之间创建一个关联(引用)，这样一个对象就可以通过委托访问另一个对象的属性和函数。 委托这个术语可以更加准确地描述 JavaScript 中对象的关联机制。

>JavaScript 开发者绞尽脑汁想要模仿类的行为:

对象委托：建立两个对象的关联
``` js
const obj = Object.create(obj1)
// obj1 关联到 obj，obj1 的属性在obj 的原型上
// 这样关联，属性的修改，对应的对象也会修改
```
人性化：
“鸭子类型”。这个术语源自这句格言“如果看起来像鸭子，叫起来像鸭子， 那就一定是鸭子。”
ES6 的 Promise 就是典型的“鸭子类型”
### 行为委托
在软件架构中你可以选择是否使用类和继承设计模式。大多数开发者理所当然地认为类是唯一(合适)的代码组织方式，但是本章中我们看到了另一种更少见但是更强大的设计模式:行为委托。
行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript 的[[Prototype]] 机制本质上就是行为委托机制。也就是说，我们可以选择在 JavaScript 中努 力实现类机制(参见第 4 和第 5 章)，也可以拥抱更自然的 [[Prototype]] 委托机制。
当你只用对象来设计代码时，不仅可以让语法更加简洁，而且可以让代码结构更加清晰。 对象关联(对象之前互相关联)是一种编码风格，它倡导的是直接创建和关联对象，不把它们抽象成类。对象关联可以用基于 [[Prototype]] 的行为委托非常自然地实现。

### class
小结:
class 很好地伪装成 JavaScript 中类和继承设计模式的解决方案，但是它实际上起到了反作用:它隐藏了许多问题并且带来了更多更细小但是危险的问题。
class 加深了过去 20 年中对于 JavaScript 中“类”的误解，在某些方面，它产生的问题比解决的多，而且让本来优雅简洁的 [[Prototype]] 机制变得非常别扭。
结论:如果 ES6 的 class 让 [[Prototype]] 变得更加难用而且隐藏了 JavaScript 对象最重要的机制——对象之间的实时委托关联，我们难道不应该认为 class 产生的问题比解决的多吗?难道不应该抵制这种设计模式吗?

