# hooks 源码之前：先了解原理 动机 原理 源码

> 做工程是一个不断妥协的过程，永远不可能有一个完美无缺的设计。现实生活中的工程设计更像断臂维纳斯，既有遗憾也有缺陷，这就形成了妥协点。

> 工程化的东西最终应该落地到工具上
## 为什么使用 hooks，设计动机初探
### 函数组件与类组件的对比：无关“优劣”，只谈“不同”
1. 类组件需要继承 class，函数组件不需要；

2. 类组件可以访问生命周期方法，函数组件不能；

3. 类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以；

4. 类组件中可以定义并维护 state（状态），而函数组件不可以等等

> 在 React-Hooks 出现之前的世界里，类组件的能力边界明显强于函数组件

### class 组件的缺陷 (包裹在面向对象思想下的“重装战舰”)
> 类组件的两大痛点：this 和 生命周期（学习成本，不合理的逻辑组织方式）

1. 组件之间难以复用状态逻辑。过去常见的解决方案是高阶组件、render props 及状态管理框架。（组件的嵌套地狱）

2. 复杂的组件变得难以理解。生命周期函数与业务逻辑耦合太深，导致关联部分难以拆分。
> React 类组件提供多少东西，就需要学习多少东西，**'大而全'的背后，是不可忽视的学习成本**。杀鸡用牛刀

3. 人和机器都很容易混淆类。常见的有 this 的问题，但在 React 团队中还有类难以优化的问题，他们希望在编译优化层面做出一些改进。

> 这三个问题在一定程度上阻碍了 React 的后续发展，所以为了解决这三个问题，Hooks 基于函数组件开始设计。然而第三个问题决定了 Hooks 只支持函数组件。


### 深入理解函数组件：呼应 React 设计思想的“轻巧快艇”
- 函数组件更加契合 React 框架的设计理念: React 赫赫有名的公式：**UI=render(data)** 一个吃进数据、吐出 UI 的函数。

- [函数组件会捕获 render 内部的状态，这是两类组件最大的不同](https://overreacted.io/how-are-function-components-different-from-classes/)

```js
// 类
class ProfilePage extends React.Component {
  showMessage = () => {
    alert('Followed ' + this.props.user);
  };
  handleClick = () => {
    setTimeout(this.showMessage, 3000);
  };
  render() {
    return <button onClick={this.handleClick}>Follow</button>;
  }
}
// 函数
function ProfilePage(props) {
  const showMessage = () => {
    alert('Followed ' + props.user);
  };
  const handleClick = () => {
    setTimeout(showMessage, 3000);
  };
  return (
    <button onClick={handleClick}>Follow</button>
  );
}
```
- 通过快照问题对比，**函数组件真正的把数据和渲染紧紧的绑在一起**

> tips：类组件 和 函数组件之间纵有千差万别，但最不能够被忽视的是**心智模式的差异**（面向对象编程，函数式编程）


### Hooks 的本质：一套能够使函数组件更强大、更灵活的“钩子”
- 函数组件比起类组件“少”了很多东西，比如生命周期、对 state 的管理等。这就给函数组件的使用带来了非常多的局限性，导致我们并不能使用函数这种形式，写出一个真正的全功能的组件。

- React-Hooks 的出现，就是为了帮助函数组件补齐这些（相对于类组件来说）缺失的能力。

- 如果说函数组件是一台轻巧的快艇，那么 React-Hooks 就是一个内容丰富的零部件箱。“重装战舰”所预置的那些设备，这个箱子里基本全都有，同时它还不强制你全都要，而是**允许你自由地选择和使用你需要的那些能力**，然后将这些能力以 Hook（钩子）的形式“钩”进你的组件里，从而定制出一个最适合你的“专属战舰”。

> 有时候，我们必须学会忘记旧的知识，才能够更好地拥抱新的知识。对于每一个学习 useEffect 的人来说，生命周期到 useEffect 之间的转换关系都不是最重要的，最重要的是在脑海中构建一个“组件有副作用 → 引入 useEffect”这样的条件反射。当你真正抛却类组件带给你的刻板印象、拥抱函数式编程之后，想必你会更加认同“useEffect 是用于为函数组件引入副作用的钩子”这个定义。

### 保持清醒：hooks 不是万能的：
- **Hooks 暂时还不能完全地为函数组件补齐类组件的能力**：比如 getSnapshotBeforeUpdate、componentDidCatch 这些生命周期，目前都还是强依赖类组件的。官方虽然立了“会尽早把它们加进来”的 Flag，但是说真的，这个 Flag 真的立了蛮久了……（**文章时间点 2020/11/**）

- **“轻量”几乎是函数组件的基因，这可能会使它不能够很好地消化“复杂”**：我们有时会在类组件中见到一些方法非常繁多的实例，如果用函数组件来解决相同的问题，业务逻辑的拆分和组织会是一个很大的挑战。我个人的感觉是，从头到尾都在“过于复杂”和“过度拆分”之间摇摆不定，哈哈。耦合和内聚的边界，有时候真的很难把握，函数组件给了我们一定程度的自由，却也对开发者的水平提出了更高的要求。

- **Hooks 在使用层面有着严格的规则约束**：对于如今的 React 开发者来说，如果不能牢记并践行 Hooks 的使用原则，如果对 Hooks 的关键原理没有扎实的把握，很容易把自己的 React 项目搞成大型车祸现场。

### hooks两条使用原则：
1. 只在 React 的函数组件中调用 Hook。
2. 不要在循环、条件或嵌套函数中调用 Hook；
> 只需要在 ESLint 中引入 eslint-plugin-react-hooks 完成自动化检查就可以检测上面说的问题。
> 为什么不要在循环、条件或嵌套函数中调用 Hook 呢？因为 Hooks 的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。当然，实质上 React 的源码里不是数组，是链表。

### Hooks 是如何关联对应组件的：一个函数组件内的 Hooks 通过链表的形式存储，最后挂载到 fiber 的 memoizedState 属性上。


### 强调“源码流程”而非“源码”，主要有两方面的考虑：
- React-Hooks 在源码层面和 Fiber 关联十分密切，目前仍然处于基础夯实阶段，对 Fiber 机制相关的底层实现暂时没有讨论，盲目啃源码在这个阶段来说没有意义；

- 原理 !== 源码，阅读源码只是掌握原理的一种手段，在某些场景下，阅读源码确实能够迅速帮我们定位到问题的本质（比如 React.createElement 的源码就可以快速帮我们理解 JSX 转换出来的到底是什么东西）；而 React-Hooks 的源码链路相对来说比较长，涉及的关键函数 renderWithHooks 中“脏逻辑”也比较多，整体来说，学习成本比较高，学习效果也难以保证。
- **同时也不建议你在对 Fiber 底层实现没有认知的前提下去和 Hooks 源码死磕。**

### 以 useState 为例，分析 React-Hooks 的调用链路
- 抛一个疑问哈，react用链表来严格保证hooks的顺序，这样设计的理念是什么呢？为什么不用其他方法来取state，取消固定顺序岂不是更加灵活吗？



### 新方向
为什么会有Server Components
Dan首先介绍了我们在项目开发中需要考虑的三个点：

Good：好的用户体验
Cheap：维护成本低
Fast：性能好
[相关链接](https://zhuanlan.zhihu.com/p/340816128)


1、Server Components有局限性，比如不能使用state、effects、以及浏览器的一些API，那么只适合用在纯展示的组件，对性能要求较高的一些前台业务，比如商品列表、会场页，还是挺适用的

2、Server Components扩展了前端技术边界，往业务层又推进了一步，maybe是BFF的一个新思路

3、落地需要很多配套基建和工具链，当然，后续肯定会逐步完善。不过如果后续想在业务中使用，还是要考虑ROI，毕竟对大多数项目来说，Dan介绍的那些痛点并没有那么“痛”

相关文章：
https://zhuanlan.zhihu.com/p/37095662
